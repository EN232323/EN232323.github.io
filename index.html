<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-PTF" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/PTF/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:47:33.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/PTF/">PTF</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>看得见，摸得着</li>
<li>外观，简单的交互，界面的显示</li>
<li>HTML    JS</li>
<li>cookie：用户身份</li>
</ul>
<h4 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h4><h5 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h5><ul>
<li>设置搜索prox,,手动代理配置，输入http代理和端口</li>
<li>使用插件proxy</li>
</ul>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>业务处理逻辑之所在</li>
<li>输入处理的地方，数据存储的地方</li>
</ul>
<h4 id="代码找寻（php"><a href="#代码找寻（php" class="headerlink" title="代码找寻（php)"></a>代码找寻（php)</h4><ul>
<li>robots.txt</li>
<li>Comment</li>
<li>.pyc</li>
<li>.DS_Store（临时脚本）</li>
<li>.git（版本管理）</li>
<li>.svn</li>
<li>bak file(.tar.gz&#x2F;.rar&#x2F;.zip&#x2F;.7z)</li>
<li>查看页内源代码</li>
<li>pyc文件（反汇编）</li>
</ul>
<h5 id="vim-swap-backup-file-bak-php-php-php-swp"><a href="#vim-swap-backup-file-bak-php-php-php-swp" class="headerlink" title="vim swap&#x2F;backup file(.bak&#x2F;.php.&#x2F;.php~&#x2F;.php.swp)"></a>vim swap&#x2F;backup file(.bak&#x2F;.php.&#x2F;.php~&#x2F;.php.swp)</h5><h6 id="backup-file-文件备份"><a href="#backup-file-文件备份" class="headerlink" title="backup file(文件备份)"></a>backup file(文件备份)</h6><ul>
<li>web.tar.gz</li>
<li><a target="_blank" rel="noopener" href="http://www.zip/">www.zip</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tar.gz/">www.tar.gz</a></li>
<li>web.rar</li>
<li>…….</li>
</ul>
<h4 id="弱类型比较问题"><a href="#弱类型比较问题" class="headerlink" title="弱类型比较问题"></a>弱类型比较问题</h4><ul>
<li>可以是整型或者浮点型，无明确指定</li>
<li>强类型与弱类型：-C++，Java是强类型，需要提前声明变量类型和名称；不经强制转换则永远是该数据类型 。 -弱类型要求不严格，可以类型相互转换。</li>
<li>“&#x3D; &#x3D;”和”&#x3D; &#x3D; &#x3D;”的区别：<br>  “&#x3D; &#x3D;”如果两边类型不同，会自动转化类型。<br> 1.字符串和数字比较，字符串会被转化成数字：如：”admin”&#x3D; &#x3D;0（true) (admin会被转换成数字，由于admin是字符串，转换失败，所以会转换为0，所以0&#x3D; &#x3D;0，所以是正确的)<br> 2.混合字符串转化为数字，看字符串的第一个（”1admin”&#x3D; &#x3D;1 , “2admin”&#x3D; &#x3D;2)<br> 3.字符串开头以xex开头，x代表数字，会被转换成科学计数法。（1e9&#x3D; &#x3D;1x（10的九次方））<br>-“&#x3D; &#x3D; &#x3D;“要求类型是相同的</li>
</ul>
<h3 id="请求包–相应包"><a href="#请求包–相应包" class="headerlink" title="请求包–相应包"></a>请求包–相应包</h3><ul>
<li>浏览器发送请求包</li>
<li>服务器回复响应包</li>
<li>格式解析</li>
</ul>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>破解，利用成功（程序的二进制漏洞）</li>
<li>攻破（设备，服务器）</li>
<li>控制（设备，服务器）</li>
</ul>
<hr>
<ul>
<li><strong>exploit</strong> : 用于攻击的脚本与方案</li>
<li><strong>payload</strong> :攻击载荷，是目标进程被劫持控制流的数据</li>
<li><strong>shellcode</strong> :调用攻击目标的shell的代码</li>
</ul>
<h1 id="逆向-（Reverse）"><a href="#逆向-（Reverse）" class="headerlink" title="逆向 （Reverse）"></a>逆向 （Reverse）</h1><h2 id="解题流程"><a href="#解题流程" class="headerlink" title="解题流程"></a>解题流程</h2><p>1.<strong>突破保护<br>2.定位关键代码<br>3.动静结合<br>4.破解算法</strong></p>
<h2 id="CTF逆向tips"><a href="#CTF逆向tips" class="headerlink" title="CTF逆向tips"></a>CTF逆向tips</h2><ul>
<li>集中原则</li>
<li>代码复用（github中搜索）</li>
<li>七分逆向三分猜</li>
<li>区分代码（人为编写：库函数代码，出题人代码，编译器自动附加代码）</li>
</ul>
<hr>
<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>软件</strong>：010<br>十六进制：</p>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><h2 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h2><ul>
<li>流量包</li>
<li>压缩包</li>
<li>固件分析</li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>base64</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/PTF/" data-id="cm8vgj7ui0000z8v6btfh8z9g" data-title="PTF" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MISC-隐写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/MISC-%E9%9A%90%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:46:38.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/MISC-%E9%9A%90%E5%86%99/">MISC-隐写</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>把秘密隐藏到普通的信息中，但是目前的隐写术是将某些秘密信息隐藏于数字媒介中，而又不损害载体原来信息的表达，从而掩盖秘密信息。常见的隐写载体包括文本，图像，音频，视频等。比赛中主要考察两点：隐写方法的识别和信息提取。</p>
<h3 id="图像隐写"><a href="#图像隐写" class="headerlink" title="图像隐写"></a>图像隐写</h3><p>常见的分为：插入隐写和替换隐写</p>
<h4 id="插入隐写"><a href="#插入隐写" class="headerlink" title="插入隐写"></a>插入隐写</h4><p> 指利用文件格式的冗余性，在不影响文件的正常使用从而隐藏信息，这种方法会导致文件的大小发生变化，隐藏信息可能被插入到末尾（追加插入法）或者开头（前置插入法）</p>
<h5 id="追加插入法"><a href="#追加插入法" class="headerlink" title="追加插入法"></a>追加插入法</h5><p>windows会根据后缀名解析文件，文件结束标志后得数据不会被解析，对于linux系统而言，区别是根据文件头识别类型而不是给文件尾部。</p>
<h5 id="前置插入法"><a href="#前置插入法" class="headerlink" title="前置插入法"></a>前置插入法</h5><p>将数据插入到文件按头部的冗余部分，有一些文件在设计时会保留一块数据区作为批注信息。</p>
<h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><p>指文件的属性，比如：大小，数据类型，拥有者等等，可能隐藏信息。</p>
<h4 id="替换隐写（常考）"><a href="#替换隐写（常考）" class="headerlink" title="替换隐写（常考）"></a>替换隐写（常考）</h4><p>将几乎不影响文件内容的数据进行修改，达到隐藏信息的目的，最常见的是最低比特位隐写（LSB隐写）。因为有损压缩会损毁修改掉的微小信息。</p>
<h5 id="LSB（最不显著位）隐写"><a href="#LSB（最不显著位）隐写" class="headerlink" title="LSB（最不显著位）隐写"></a>LSB（最不显著位）隐写</h5><ul>
<li>在图像中，每一个通道由8比特构成，像素值在0~255之间，在单通道图像中，通过不同的黑白比例达到不同的灰度。</li>
<li>三通道图像中（RGB），每个通道代表红，绿，蓝（利用三种颜色通道的最后一位隐藏信息,)，在RGBA图像中，多出一个透明度通道。因为二进制数据的最后一位大小改变的影响很小，就可以在这里替换数据。更高级的LSB隐写-PLTE块隐写。</li>
<li><strong>隐写方式</strong>：每一个色素都由RGB（红绿蓝）三种颜色组成，每种颜色的占比不同，所调出来的颜色不同。红218（11011010），绿150（10010110），红（10010101），假如改变每种颜色二进制数字的最后一位，对于整体的颜色改变， 肉眼并不能观察出来，从而达到隐藏信息的目的。</li>
<li>左右选择不同的色彩通道，可以查看不同通道下的图片，出题人可能在某个通道里面加入一个二维码之类的<br> 例题讲解</li>
</ul>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png"></p>
<p>把图片放到stegsolve中，然后dataextract，然后勾选LSB，再把RGB最低位勾选出来，然后预览（preview），右边那一大堆是实体编码，把多于元素去掉之后，把它转换为16进制</p>
<p>例题二：</p>
<p>按照上述步骤操作之后，得到</p>
<p>![[Pasted image 20241027220206.png]]</p>
<p>只有6个字母，联想到16进制，将zwxyv映射到abcde，解码得到flag。</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png"></p>
<p>所有的数字只有两种类型，0和255，那么不是白色就是黑色，一共有160000个数据，那么我们可以联想到400*400的一个二维码图片<br>执行右边的脚本即可得到图片。</p>
<h5 id="PNG图片（无损压缩"><a href="#PNG图片（无损压缩" class="headerlink" title="PNG图片（无损压缩)"></a>PNG图片（无损压缩)</h5><ul>
<li><p>我们之所以能看到图片，就是因为图片查看器将图片所对应的二进制字节流按照它的解释规则将图片转换为色素块，很多色素块拼成了图片，因此，分析一个图片通常是查看它的原始二进制字节流。</p>
</li>
<li><p>使用010editor （文件结构查看工具）来获得图片的16进制参数。</p>
</li>
<li><p>一个PNG图片的数据可以分为多个数据块。</p>
</li>
<li><p>PNG图片文件头的16进制表示：89 50 4E 47</p>
</li>
<li><p>IHDR数据块：文件头数据块，通常包含图片的高度和宽度等基本属性，可以通过将crc还原出来所对应的高度和宽度来找到flag。<br><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png"></p>
<p>在IHDR数据块中找到ihdr，在这里有图片的高度和宽度信息，假如一个图片的高度为200，但是出题人修改高度为150，那么我们在拿到这个题目进行查看时，只能看到150高度的信息，出题人可能将信息隐藏到另外50高度里面，那么我们就可以通过分析IHDR数据块的crc，从而不断的更改高度直到某个高度所对应的crc和分析所得到的crc一样，那么就得到了正确高度，从而得到隐藏信息</p>
</li>
<li><p>cHRM数据块。</p>
</li>
<li><p>IDAT数据块（多个）（包含图片内容）：包含了数据的构成参数。如果该数据块有问题，有一种题型是在该数据块中存有压缩包，通过Zlib工具解压缩查看内容。</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png"> <img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png"></p>
<p> 上面已经提到，IDAT数据块包含了PNG图片的内容，有多个IDAT数据块。<br><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png"></p>
<p>每一个IDAT数据块都包含了多个字节流，前面已经说过，图片是由字节流组成的。<br><strong>考察点（crc校验）</strong>：<br>每个数据块都含有一个不同的crc参数，可以通过题目图片的crc与自己通过工具将数据块分析出来的crc是否相同来判断该数据块是否有问题。（PNGcheck工具来分析数据块的crc）。可以把crc理解为数据块的“身份证”<br> <strong>实际出题格式之一</strong>：<br>可能在问题数据块中压缩隐藏文件，那么我们就把数据块提取出来，解压缩分析</p>
</li>
<li><p>IEAD数据块：图片结束标志。</p>
</li>
</ul>
<h5 id="JPG图片（有损或无损）"><a href="#JPG图片（有损或无损）" class="headerlink" title="JPG图片（有损或无损）"></a>JPG图片（有损或无损）</h5><ul>
<li>由一个一个段组成</li>
<li>文件头识别：FFD8</li>
</ul>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png"></p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg"></p>
<p>常用工具：silenteye，steghide，stegsolve</p>
<h5 id="GIF（无损）"><a href="#GIF（无损）" class="headerlink" title="GIF（无损）"></a>GIF（无损）</h5><ul>
<li>文件头：GIF89a&#x2F;GIF87a（都是可打印字符），文件伪装很方便，只需开头就是GIF89a&#x2F;GIF87a就可以，而png或者jpg需要用工具才能伪装，因为他的文件头不是可打印字符，与文件上传相结合出题，如果题目要求上传一个GIF文件，那么我们可以在一句话木马前面加上GIF89a&#x2F;GIF87a，那它就是“GIF”文件了</li>
<li>出题方式：<br> 追加插入<br>基于图像的隐写（由于它是一个动图，所以可能在某一帧插入敏感信息）<br>基于时间的隐写（不同的延迟时间代表不同的数据）<br>Kali中提取延迟时间的命令</li>
<li>做题方法<br>用identify命令获取每一帧之间的时间间隔，想想有没有可能和密码学结合起来，每一帧的时间间隔对应一个字符。</li>
</ul>
<h4 id="图片隐写三板斧"><a href="#图片隐写三板斧" class="headerlink" title="图片隐写三板斧"></a>图片隐写三板斧</h4><h5 id="第一板斧：010editor-strings"><a href="#第一板斧：010editor-strings" class="headerlink" title="第一板斧：010editor strings"></a>第一板斧：010editor strings</h5><ul>
<li>Strings命令：strings flag.png | grep “keyword”。这样就只显示flag.png中的包含keyword的字符串</li>
</ul>
<h5 id="第二板斧：stegsolve-zsteg"><a href="#第二板斧：stegsolve-zsteg" class="headerlink" title="第二板斧：stegsolve zsteg"></a>第二板斧：stegsolve zsteg</h5><p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg"></p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg"></p>
<h5 id="第三板斧：binwalk-foremost"><a href="#第三板斧：binwalk-foremost" class="headerlink" title="第三板斧：binwalk foremost"></a>第三板斧：binwalk foremost</h5><ul>
<li>fcrackzip命令：用于爆破zip文件的密码</li>
<li>可以使用字典来爆破，这个wordlist.txt是字典，后面的zip文件就是待破解的压缩包</li>
<li>fcrackzip -D -p &#x2F;path&#x2F;to&#x2F;wordlist.txt protected.zip</li>
<li>如果密码是比较简单的格式，就可以直接使用命令</li>
<li>如果密码格式比较简单，可以直接用简单的指令进行破解<ul>
<li>fcrackzip -b -l 4 -s “0123456789” protected.zip<br>这样的格式就是密码4位全是数字</li>
<li>fcrackzip -b -l 4 -s “abcdefghijklmnopqrstuvwxyz” protected.zip<br>这样的就是4位全是字母</li>
<li>fcrackzip -b -l 4 -s “abcdefghijklmnopqrstuvwxyz0123456789” protected.zip<br> 这样就是小写字母与数字的集合</li>
</ul>
</li>
<li>Foremost：直接提取可能隐藏在图片中的文件</li>
<li>Binwalk -e 1.png 也可以直接提取png图片里面的文件<br>Foremost  1.jpg<br>这样就会生成一个out文件，里面是提取出来的文件</li>
<li>Binwalk：查看该图片是否隐藏其他文件。</li>
<li>Pcrt.py：脚本工具，用于检查png图片的crc校验码从而直接修复数据</li>
<li>Zsteg：可以检测png和bmp中的隐写数据，功能非常强大，可以用它来检测LSB中的信息隐藏通道。</li>
</ul>
<h5 id="板斧升级"><a href="#板斧升级" class="headerlink" title="板斧升级"></a>板斧升级</h5><ul>
<li>第一板斧升级：利用png图片中的crc进行图片的宽高修复等。</li>
<li>第二板斧升级：可能将LSB中隐藏的信息加密成密文，这是我们需要找到密钥破解。</li>
<li>工具：cloacked-pixel中的lsb.py脚本</li>
</ul>
<h3 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h3><ul>
<li>首要关注：音频中有关基本属性（标题，创作者等等）的信息。</li>
<li>音频文件后缀包括mp3（常见），wav（常见），wma，ape等等。</li>
</ul>
<h4 id="Mp3（有损）"><a href="#Mp3（有损）" class="headerlink" title="Mp3（有损）"></a>Mp3（有损）</h4><ul>
<li>主要特点是将人耳不敏感的高频部分进行压缩，保留低频部分。</li>
</ul>
<h4 id="基于波形图的隐写"><a href="#基于波形图的隐写" class="headerlink" title="基于波形图的隐写"></a>基于波形图的隐写</h4><ul>
<li>如果音频文件是单声道就只有一个波形图，如果有两个，就有两个波形图，一些规则的波形图很可能隐藏某些密文，提取出来即可分析。</li>
<li>工具：Audacity（分析波形图等等）</li>
</ul>
<h4 id="基于频谱图的隐写"><a href="#基于频谱图的隐写" class="headerlink" title="基于频谱图的隐写"></a>基于频谱图的隐写</h4><p>直接查看频谱图即可</p>
<h4 id="音频LSB隐写"><a href="#音频LSB隐写" class="headerlink" title="音频LSB隐写"></a>音频LSB隐写</h4><ul>
<li>经常使用silenteye来进行分析隐写题目，需要密码。</li>
<li>MP3文件隐写：Mp3文件（有损压缩，其出题范围很小）：Mp3Stego（提取隐藏在mp3或者wav中隐藏文件的工具），当用mp3stego解码时，需要把mp3放在Decode.exe相同的文件夹下。</li>
</ul>
<h4 id="拨号音识别"><a href="#拨号音识别" class="headerlink" title="拨号音识别"></a>拨号音识别</h4><h4 id="脉冲拨号原理"><a href="#脉冲拨号原理" class="headerlink" title="脉冲拨号原理"></a>脉冲拨号原理</h4><p>拨号盘在回转的时候控制电路节点的断和续，拨3，断续3次，拨0，断续10次以此类推。这个不容易被交换机识别且太慢。</p>
<h4 id="双音多频拨号原理"><a href="#双音多频拨号原理" class="headerlink" title="双音多频拨号原理"></a>双音多频拨号原理</h4><p>每个数字或字符都由一个高频和一个低频组成。</p>
<h4 id="音频隐写总结："><a href="#音频隐写总结：" class="headerlink" title="音频隐写总结："></a>音频隐写总结：</h4><ul>
<li>先用010查看是否有隐藏文件或者冗余信息</li>
<li>然后使用audacity查看波形图或者频谱图</li>
<li>最后如果是wav文件，考虑LSB隐写（Silenteye），如果是mp3文件，使用mp3stego</li>
</ul>
<h3 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h3><ul>
<li>视频就是图像和音频的总和，只要把两者分离出来就可以按照思路解题，常见的视频文件格式为avi，mov，rmvb和mp4等。</li>
<li>对于视频的帧提取，可以用ffmpeg或者video to picture，对于flash文件的提取，可以用flash decompiler trillix。</li>
</ul>
<h3 id="文本隐写"><a href="#文本隐写" class="headerlink" title="文本隐写"></a>文本隐写</h3><p>文本内容的隐写（基本上归于密码）</p>
<h3 id="Word隐写"><a href="#Word隐写" class="headerlink" title="Word隐写"></a>Word隐写</h3><p>最基本的是在文件属性中隐藏信息，也可以通过写入白色文字，插入文本框或者图形遮挡等<br>由于word文件头和zip一样，所以都可以改后缀，解压</p>
<h3 id="PDF的隐写"><a href="#PDF的隐写" class="headerlink" title="PDF的隐写"></a>PDF的隐写</h3><p>一个pdf文件分为头部，文件体和交叉引用表和尾部4部分。<br>头部：pdf文件第一行是标识字符，随后跟的是版本号</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg"></p>
<p>文件体：由文件内容的一系列obj对象组成</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg"></p>
<p>交叉引用表：标识字符是xref</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg"></p>
<p>尾部：</p>
<p><img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg"></p>
<p>Pdf的隐写比较复杂</p>
<h5 id="总结常见套路"><a href="#总结常见套路" class="headerlink" title="总结常见套路"></a>总结常见套路</h5><p>1：利用图片遮挡住隐藏的内容<br>2：在pdf文字里面隐藏信息，这里我们用kali自带的工具提取所有的文本内容，查看隐藏的信息<br> pdftotext 1.pdf flag.txt<br> 将1.pdf里面的内容提取出来保存在flag.txt里面<br>3：利用obj对象隐藏信息。Obj中的对象经过zlib算法压缩，插入到经过压缩的obj对象，利用该对象隐藏信息。使用工具PDFStreamDumper即可查看obj对象解压缩。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/MISC-%E9%9A%90%E5%86%99/" data-id="cm8vgi2p4000168v6gggh5ekw" data-title="MISC-隐写" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HTML" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/HTML/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:45:28.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/HTML/">HTML</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="html-限定了文档的开始点和结束点"><a href="#html-限定了文档的开始点和结束点" class="headerlink" title="html:限定了文档的开始点和结束点"></a>html:限定了文档的开始点和结束点</h2><p>head:可加title标签<br>body:正文，标题标签:&lt;   h1&gt; 一级标题&lt;&#x2F;h 1&gt;(共有六级标题)<br>p:段落标签<br>br:换行标签<br>a:超链接&lt;a href&#x3D;”链接“target&#x3D;”…”&gt;名称</a><br>注释标签：<!--...-->(快捷键：Ctrl+？)<br>有序列表：<oi>(会标上123)<br>             <li>list 1</li><br>             …<br>        </oi><br>无序列表：<ul><br>            <li>list 1</li><br>             …<br>        </ul><br>table:表格标签<br>      &lt; table&gt;<br>          <thead>(表头)<br>              <tr>(tr代表一行)<br>                <th>姓名</th><br>                <th>性别</th><br>            </tr><br>        </thead><br>        <tbody>(表的主体)<br>              <tr><br>                  <td>一曲</td><br>                  <td>男</td><br>            </tr><br>            <tr><br>                 <td>三石</td><br>                 <td>男</td><br>            </tr><br>        </tbody><br>    </table><br>form:表单：<br>     &lt;form action&#x3D;”提交给谁(#代表提交给自己)”&gt;<br>          账号：&lt; input type&#x3D;”text” name&#x3D;”username”&gt;<br><br>          密码:  &lt; input  type&#x3D;”text” name&#x3D;”password”&gt;<br><br>          <input type="submit"><br>    </form><br>img:图片标签<br>    &lt;   img src&#x3D;   “图片文件名及地址（要放在同一文件夹里）或图片链接） alt&#x3D;”加载失败“    &gt;<br>style:样式标签</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/HTML/" data-id="cm8vgi2p2000068v61mruf6rz" data-title="HTML" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-base64解码脚本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/base64%E8%A7%A3%E7%A0%81%E8%84%9A%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:44:36.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/base64%E8%A7%A3%E7%A0%81%E8%84%9A%E6%9C%AC/">base64解码脚本</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>![[Pasted image 20250319204550.png]]<br>old为原来的顺序，new为此题目定义的顺序，(即此题目中Base中的A为q,B为v，以此类推）encoded为密文，解开后即为flag.<br>import base64</p>
<p>new&#x3D;”qvEJAfHmUYjBac+u8Ph5n9Od17FrICL&#x2F;X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD”</p>
<p>old&#x3D;”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;“</p>
<p>encoded&#x3D;”5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM&#x2F;8&#x3D;&#x3D;”</p>
<p>mapper&#x3D;str.maketrans(new,old)</p>
<p>tmp&#x3D;encoded.translate(mapper)</p>
<p>flag&#x3D;base64.b64decode(tmp)</p>
<p>print(flag.decode())</p>
<p>![[Pasted image 20250319204802.png]]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/base64%E8%A7%A3%E7%A0%81%E8%84%9A%E6%9C%AC/" data-id="cm8vgf6i00000q0v6ejxoclqe" data-title="base64解码脚本" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/python/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:43:26.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/python/">python</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>type():表示类型</li>
<li>字符串内同时包含：‘和 “，可以用\（转义字符）来标识（I’m&quot;OK&quot;!”)</li>
<li>\ (转义字符 )：\n换行；\t制表符；\ \打印;</li>
</ul>
<h2 id="字符串（string"><a href="#字符串（string" class="headerlink" title="字符串（string)"></a>字符串（string)</h2><p>由字符（如：字母，汉字，数字，符号）组成的序列，不可变<br>‘ ‘和“”用于单行字符串，“”“ ”“”用于多行字符串。</p>
<ul>
<li>Unicode字符串：不以u&#x2F;U,r&#x2F;R,b&#x2F;B开头的字符串</li>
<li>非转义的原始字符串:以r&#x2F;R开头</li>
<li>bytes字符串：以b&#x2F;B开头</li>
<li>可以使用econde()和decode()函数进行编码和解码，同样也可以使用str()和bytes()函数进行相同的操作（a&#x3D;a.encode()将str转换为bytes)</li>
<li>ascill_letters: 所有大小写字母<br>ascill_lowercase:所有小写字母<br>ascill_uppercase: 所有大写字母<br>digits:0123456789<br>hexdigits:0123456789abcdefABCDEF<br>octdigits:01234567<br>printable:所有可打印字符<br>punctuation:所有标点符号</li>
</ul>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>my_list<br>复合数据类型，支持字符，数字，字符串，列表（即嵌套），同一个列表里面所有元素类型可以不同。<br>列表中的值的切割也可以用到变量[ 头下标:尾下标 ]，就可以截取相应列表，从左到右索引默认0开始，从右到左默认-1开始，下标可以为空表示取到头或尾。</p>
<ul>
<li>print(a[0:3])：可打印字符串的前三个字符</li>
<li>print(a[-3]):倒数第三个字符</li>
<li>a [3]&#x3D;x:可修改第三个字符为x</li>
<li>print(‘，’.join(a)):a中字符以，隔开</li>
</ul>
<h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h2><p>my_tuple<br>元组是另一个数组类型，用（）标识，内部元素用逗号隔开，不能二次赋值，支持索引及切片</p>
<h2 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary(字典)"></a>Dictionary(字典)</h2><p>my_dict</p>
<ul>
<li>字典与列表的区别在于：字典中的元素通过键来存取，而不是通过偏移来存取。字典用{}标识，由键（key）和它对应的值（value）组成。</li>
<li>my_dict[“key”]&#x3D;”value”</li>
<li>print(my_dict.keys()):输出键列表</li>
<li>访问值：print(my_dict[“name”])</li>
<li>修改：my_dict[“name”]&#x3D;”test”</li>
<li>删除键值对：my_dict.pop(“name”)</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>&#x2F;&#x2F;：整除：向下取整</li>
<li>** ：x的y次幂</li>
<li>x and y:输出y</li>
<li>x or y:输出x</li>
<li>a^b&#x3D;c     b^c&#x3D;a     a^c&#x3D;b</li>
</ul>
<h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a>条件运算</h2><p>if():<br>elif():<br>else():</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><ul>
<li>可以遍历任何序列项目，如字符串，列表，元组</li>
<li>for 迭代变量 in 序列<br>  执行语句（statements)</li>
<li>遍历列表：（1）fruits&#x3D;{‘a’,’b’,’c’}<br>         for fruit in fruits :<br>          print  (‘当前水果：%s’ % fruit)<br>      （2）fruits&#x3D;{‘a’,’b’,’c’}<br>          for i in range(len(fruits)):<br>           print(‘当前水果：%s’ % fruits[i]) </li>
<li>len():返回变量的长度</li>
</ul>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>pass:空语句</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>def 函数名 （）<br> 执行语句（statements)<br> return 返回值1，返回值2…</li>
</ul>
<h4 id="import机制"><a href="#import机制" class="headerlink" title="import机制"></a>import机制</h4><p>以.py结尾的文件</p>
<ul>
<li>调用不同文件的函数(导入模块的指定部分到当前命名空间中)<br>  1.import mylib<br>  print(mylib.add(1,2))<br>  print(mylib.flag)<br> 2.from lib import add,flag<br>  print(add(1,2))<br>  print(flag)</li>
<li>把一个模块的所有内容全都导入到当前命名空间中<br>   from mylib import *<br>   print(add.(1,2))<br>   print(flag)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/python/" data-id="cm8vgdvuy0000uov69wica6d8" data-title="python" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-x86-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/x86-2/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:40:56.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/x86-2/">x86.2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><p>eflag:<br>![[eflags 1.png]]</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（Stack）是一种常见的数据结构，在计算机科学中具有重要的应用价值。栈的操作受限于后进先出（LIFO, Last In First Out）的原则，这种特点使得栈在处理特定类型的问题时非常高效。本文将详细解析栈的本质和特点，并通过生活中的例子和代码实现来深入理解栈的应用。</p>
<h3 id="栈的本质和特点"><a href="#栈的本质和特点" class="headerlink" title="栈的本质和特点"></a>栈的本质和特点</h3><p>栈是一种线性数据结构，只允许在一端进行插入和删除操作，这一端称为栈顶（Top）。与栈顶相对的另一端称为栈底（Bottom），栈底是固定的，不进行操作</p>
<h3 id="栈有几种基本操作："><a href="#栈有几种基本操作：" class="headerlink" title="栈有几种基本操作："></a>栈有几种基本操作：</h3><p>压栈（Push）：将一个元素添加到栈顶。<br>出栈（Pop）：移除并返回栈顶元素。<br>取栈顶元素（Peek or Top）：返回栈顶元素但不移除它。<br>检查栈是否为空（isEmpty）：返回布尔值，指示栈是否为空。<br>检查栈是否已满（isFull）：返回布尔值，指示栈是否已满（主要用于固定大小的栈）。</p>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><ul>
<li>后进先出<br>栈的最主要特点是后进先出，即最新加入的元素最先被移除。这种特性使得栈特别适用于某些特定的应用场景。</li>
<li>操作受限<br>与其他数据结构相比，栈的操作比较受限。只能在栈顶进行压栈和出栈操作，不能直接访问栈中的任意元素。</li>
<li>动态调整<br>栈可以是固定大小的，也可以是动态调整大小的。动态栈会根据需要自动调整其容量。</li>
</ul>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><ul>
<li>程序栈用于存放进程运行期间所需的部分数据（存放局部变量，暂存函数返回地址，传递的参数，部分寄存器）</li>
<li>在程序运行过程中，栈中的数据变化过程是程序操作数据的本质体现</li>
<li>栈可以用于追踪程序的函数调用过程</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>定义：堆是动态分配内存。程序在运行时可以用 malloc 或 new 申请任意大小的内存，程序员需要负责在适当的时候用 free 或 delete 释放内存。</li>
<li>如果某动态内存不再使用，需要将其释放掉，否则会发生内存泄露现象</li>
<li>特点：堆是从低地址向高地址增长的。</li>
</ul>
<h2 id="进程空间布局"><a href="#进程空间布局" class="headerlink" title="进程空间布局"></a>进程空间布局</h2><ul>
<li>进程的内存空间在结构上是有规律的，特别是对于Linux系统上的进程，其内存空间一般可以粗略地分为几大段，从高内存到低内存排列如下：</li>
<li>内核态内存空间：其大小一般比较固定（可以在编译时调整），32位系统和64位系统的值不一样。</li>
<li>用户态的堆段：大小不固定，可以用 ulimit -s 进行调整，默认一般为8M，从高地址向低地址增长。</li>
<li>数据段：主要是进程初始化和未初始化的全局数据总和，还有编译器生成的一些辅助数据结构，大小取决于具体进程，其位置紧挨着堆段。</li>
<li>代码段：主要是进程的指令，包括用户代码和编译器生成的辅助代码，大小取决于具体程序，但起始位置在32位还是64位一般固定（-fPIC，-fPIE等除外）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/x86-2/" data-id="cm8vgb38r0000vsv6299j9e5v" data-title="x86.2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-x86" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/x86/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:38:15.000Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/x86/">x86</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><h4 id="字长与端序"><a href="#字长与端序" class="headerlink" title="字长与端序"></a>字长与端序</h4><ol>
<li>内存存储单位</li>
</ol>
<ul>
<li><p>内存以字节为单位。一个字节是8个比特位，可以表示2^8 &#x3D; 256个数。大小为8位的二进制数是从0开始到255这256个值中的一个。</p>
</li>
<li><p>两个字节被称为一个字（WORD，32位），四个字节被称为双字（DWORD，32位），八个字节被称为四字（QWORD，64位）。<br>2. 字节排列顺序（端序）</p>
</li>
<li><p>字节的排列顺序有两种通用规则：</p>
</li>
<li><p>大端序（Big - Endian）：将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。</p>
</li>
<li><p>小端序（Little - Endian）：将数据的低位字节存放在较小的地址，高位字节存放在较大的地址。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。</p>
</li>
</ul>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>控制单元（Control Unit）</p>
<ul>
<li>功能：取码、译码，控制运算单元完成运算。</li>
<li>解释：控制单元负责从内存中获取指令（取码），将指令转换为计算机能理解的形式（译码），并协调运算单元进行数据处理。<br>运算单元（Arithmetic Logic Unit, ALU）</li>
<li>功能：作为执行部件，执行算术运算、逻辑运算。</li>
<li>解释：运算单元负责执行实际的数学计算（如加法、乘法）和逻辑操作（如比较、判断）。<br>寄存器（Registers）</li>
<li>功能：临时数据存储（规模小，有专用、通用之分）。</li>
<li>解释：寄存器用于临时存储CPU在运算过程中需要快速访问的数据，它们的存储容量较小，但访问速度非常快，分为专用寄存器（如程序计数器）和通用寄存器（用于一般数据存储）。</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>1. 数据寄存器（4个）</p>
<ul>
<li>EAX、EBX、ECX和EDX</li>
<li>这些寄存器主要用于存储数据，在算术和逻辑运算中经常使用。例如，EAX寄存器常用于存储函数的返回值。<br>2. 变址寄存器（2个）</li>
<li>ESI和EDI</li>
<li>变址寄存器通常用于内存操作，如字符串操作和数据移动。例如，在字符串复制操作中，ESI可能指向源字符串，EDI指向目标字符串。<br>3. 指针寄存器（2个）</li>
<li>ESP和EBP</li>
<li>ESP（栈指针寄存器）用于指向栈顶，在函数调用和返回时起到关键作用。EBP（基址指针寄存器）常用于在函数内部访问局部变量和参数。<br>4. 段寄存器（6个）</li>
<li>ES、CS、SS、DS、FS和GS</li>
<li>段寄存器用于划分内存段，例如代码段（CS）、数据段（DS）、栈段（SS）等。它们帮助CPU定位不同类型的内存区域。<br>5. 指令指针寄存器（1个）</li>
<li>EIP</li>
<li>EIP（指令指针寄存器）指向当前正在执行的指令，CPU根据EIP的值来获取下一条要执行的指令。<br>6. 标志寄存器（1个）</li>
<li>eflags</li>
<li>标志寄存器存储了各种状态标志，如进位标志（CF）、零标志（ZF）、符号标志（SF）等，这些标志用于条件判断和控制程序流程。<br>![[eflags]]<br>7. 控制寄存器（9个）</li>
<li>CR0 - CR8</li>
<li>控制寄存器用于控制和配置CPU的操作模式和功能，例如CR0用于控制保护模式和实模式的切换。<br>8. 保护模式寄存器（3个）</li>
<li>GDTR、LDTR、IDTR</li>
<li>这些寄存器在保护模式下用于存储全局描述符表（GDT）、局部描述符表（LDT）和中断描述符表（IDT）的基地址和界限。</li>
</ul>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>1. EAX</p>
<ul>
<li>描述：32位，用于函数返回值。</li>
<li>解析：在程序执行过程中，函数调用完成后，返回值通常存放在EAX寄存器中。例如，在一个简单的加法函数 int add(int a, int b) 中， return a + b; 语句的结果会存放在EAX中。<br>2. AX、AH、AL</li>
<li>描述：AX是EAX的低16位，AH是AX的高8位，AL是AX的低8位。</li>
<li>解析：这是对EAX寄存器进行位拆分的方式。例如，在处理16位数据时，可以使用AX；在处理8位数据时，可以使用AH或AL。这种位拆分在汇编编程中很常见。<br>3. EBX</li>
<li>描述：32位。</li>
<li>解析：EBX通常用于存储数据的基地址。例如，在访问数组时，可以将数组的起始地址存放在EBX中，然后通过偏移量来访问数组元素。<br>4. ECX</li>
<li>描述：32位，用于循环次数，常与 this 指针相关。</li>
<li>解析：在循环操作中，ECX常用来存放循环的次数。例如，在一个 for 循环 for(int i &#x3D; 0; i &lt; n; i++) 中， n 的值可能会存放在ECX中。 this 指针在面向对象编程中指向当前对象，在某些情况下可能会与ECX寄存器相关。<br>5. EDX</li>
<li>描述：32位。</li>
<li>解析：EDX常与EAX一起使用，用于存放乘法和除法操作的结果。例如，在进行32位乘法操作时，结果的高32位存放在EDX中，低32位存放在EAX中。<br>6. EBP、ESP</li>
<li>描述：EBP是32位栈底寄存器，ESP是32位栈顶寄存器。</li>
<li>解析：在函数调用过程中，栈用于存储局部变量、参数和返回地址。EBP指向栈底，ESP指向栈顶。当函数被调用时，ESP会根据需要调整栈顶位置，而EBP保持不变，以便访问函数的局部变量。<br>7. ESI、EDI</li>
<li>描述：ESI是源索引寄存器，EDI是目标索引寄存器。</li>
<li>解析：在字符串操作和数据块移动操作中，ESI用于指向源数据的地址，EDI用于指向目标数据的地址。例如，在执行 memcpy 函数时，ESI指向源内存块，EDI指向目标内存块。</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器是计算机处理器中用于存储段基址的寄存器</p>
<p>一、实模式下的段寄存器</p>
<p>1. CS（代码段寄存器）</p>
<ul>
<li>用途：存放当前正在执行的代码段的基址。</li>
<li>计算方式：物理地址 &#x3D; CS × 16 + IP（指令指针）。</li>
<li>示例：如果CS &#x3D; 0x1000，IP &#x3D; 0x0100，那么物理地址 &#x3D; 0x1000 × 16 + 0x0100 &#x3D; 0x10100。<br>2. DS（数据段寄存器）</li>
<li>用途：存放当前数据段的基址，用于访问数据。</li>
<li>计算方式：物理地址 &#x3D; DS × 16 + 偏移量。</li>
<li>示例：如果DS &#x3D; 0x2000，偏移量 &#x3D; 0x0200，那么物理地址 &#x3D; 0x2000 × 16 + 0x0200 &#x3D; 0x20200。<br>3. SS（堆栈段寄存器）</li>
<li>用途：存放当前堆栈段的基址，用于管理堆栈操作。</li>
<li>计算方式：物理地址 &#x3D; SS × 16 + SP（堆栈指针）。</li>
<li>示例：如果SS &#x3D; 0x3000，SP &#x3D; 0x0300，那么物理地址 &#x3D; 0x3000 × 16 + 0x0300 &#x3D; 0x30300。<br>4. ES（附加段寄存器）</li>
<li>用途：存放附加数据段的基址，常用于字符串操作等。</li>
<li>计算方式：物理地址 &#x3D; ES × 16 + 偏移量。</li>
<li>示例：如果ES &#x3D; 0x4000，偏移量 &#x3D; 0x0400，那么物理地址 &#x3D; 0x4000 × 16 + 0x0400 &#x3D; 0x40400。</li>
</ul>
<p>二、保护模式下的段寄存器</p>
<p>1. CS、DS、SS、ES</p>
<ul>
<li>用途：在保护模式下，这些段寄存器不再直接存储段基址，而是存储段选择子。段选择子用于从全局描述符表（GDT）或局部描述符表（LDT）中获取段描述符，段描述符中包含段基址、段界限和访问权限等信息。</li>
<li>示例：当执行一条指令时，处理器会根据CS中的段选择子从GDT或LDT中获取对应的段描述符，然后根据段描述符中的段基址和指令指针（EIP）来计算出线性地址（在启用分页机制时，线性地址还需转换为物理地址）。</li>
</ul>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>1. 实模式下（16位环境）</p>
<ul>
<li><p>名称：IP（Instruction Pointer）</p>
</li>
<li><p>用途：</p>
</li>
<li><p>IP寄存器用于存放当前正在执行的指令相对于代码段（CS）基地址的偏移量。它与CS寄存器一起确定下一条要执行的指令的物理地址。</p>
</li>
<li><p>物理地址的计算公式为：物理地址 &#x3D; CS × 16 + IP。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>IP是16位寄存器，其值在程序执行过程中由处理器自动更新。每次执行完一条指令，IP的值会根据指令的长度增加，指向下一条指令。</p>
</li>
<li><p>程序员不能直接对IP进行赋值操作，但可以通过某些指令（如跳转指令）间接改变IP的值。<br>2. 保护模式下（32位环境）</p>
</li>
<li><p>名称：EIP（Extended Instruction Pointer）</p>
</li>
<li><p>用途：</p>
</li>
<li><p>EIP寄存器的功能与IP类似，但它是32位的，用于存放32位指令的偏移量。在保护模式下，它与CS段选择子一起确定下一条要执行的指令的线性地址（在启用分页机制时，线性地址会进一步转换为物理地址）。</p>
</li>
<li><p>线性地址的计算公式为：线性地址 &#x3D; 段基址（从GDT或LDT中获取） + EIP。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>EIP同样由处理器自动更新。在程序执行过程中，如遇到跳转、调用、返回等指令时，EIP的值会相应改变。</p>
</li>
<li><p>与实模式下的IP一样，程序员不能直接对EIP进行赋值操作，但可以通过控制转移指令来改变EIP的值。<br>3. 64位环境下</p>
</li>
<li><p>名称：RIP（Relative Instruction Pointer）</p>
</li>
<li><p>用途：</p>
</li>
<li><p>RIP是64位寄存器，用于存放64位指令的偏移量。它与CS段选择子一起确定下一条要执行的指令的线性地址（在启用分页机制时，线性地址会进一步转换为物理地址）。</p>
</li>
<li><p>线性地址的计算公式与32位类似：线性地址 &#x3D; 段基址（从GDT或LDT中获取） + RIP。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>RIP由处理器自动更新。在现代64位处理器中，指令预取、分支预测等机制都与RIP密切相关。</p>
</li>
<li><p>程序员不能直接对RIP进行赋值操作，只能通过特定的指令（如相对跳转指令）间接改变RIP的值。</p>
</li>
</ul>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><p>状态寄存器（Status Register），也称为标志寄存器（Flag<br>Register），是计算机中的一种特殊寄存器。状态寄存器用于保存关于计算机状态和执行结果的信息，通常由一组二进制位组成，每个位都对应一个特定的状态标志。</p>
<p>在x86架构中，状态寄存器通常由一些标志位组成，其中包括：</p>
<ul>
<li>零标志位（Zero Flag，ZF）：指示最近的运算结果是否为零。如果运算结果为零，则ZF被置为1，否则为0。</li>
<li>进位标志位（Carry Flag，CF）：用于处理进位和借位操作。如果最近的运算产生了进位（或借位），CF被置为1，否则为0。</li>
<li>溢出标志位（Overflow Flag，OF）：用于检测运算结果是否溢出。如果最近的运算结果造成了溢出，OF标志被置为1，否则为0。</li>
<li>符号标志位（Sign Flag，SF）：指示最近的运算结果的符号。如果结果为负数，则SF被置为1，否则为0。</li>
<li>奇偶标志位（Parity Flag，PF）：指示最近的运算结果中设置了偶数个位的数量。如果结果中偶数个位被设置为1，则PF被置为1，否则为0。</li>
<li>调整标志位（Adjust Flag，AF）：在二进制代码运算中用于处理BCD码（二进制编码的十进制数）。在一般的计算中不常使用。<br>除了上述标志位外，不同架构和处理器还可能存在其他特定的标志位。</li>
</ul>
<p>状态寄存器广泛用于控制和判断程序的执行流程，以及进行条件分支和循环控制。通过检查和设置状态寄存器中的标志位，程序可以根据运算结果和条件进行相应的操作。</p>
<h4 id="JCC指令"><a href="#JCC指令" class="headerlink" title="JCC指令"></a>JCC指令</h4><p>指令	        条件<br>JZ     	    等于（ZF&#x3D;1）<br>JE	            等于（ZF&#x3D;1）<br>JNZ	       不等于（ZF&#x3D;0）<br>JNE	       不等于（ZF&#x3D;0）<br>JA	       无符号大于（CF&#x3D;0且ZF&#x3D;0）<br>JNBE	   无符号大于（CF&#x3D;0且ZF&#x3D;0）<br>JAE	      无符号大于等于（CF&#x3D;0）<br>JNB	      无符号大于等于（CF&#x3D;0）<br>JNC	       无符号大于等于（CF&#x3D;0）<br>JB	           无符号小于（CF&#x3D;1）<br>JNAE	  无符号小于（CF&#x3D;1）<br>JBE	      无符号小于等于（CF&#x3D;1或ZF&#x3D;1）<br>JNA	     无符号小于等于（CF&#x3D;1或ZF&#x3D;1）<br>JCXZ	 CX&#x2F;ECX为零<br>JECXZ	 ECX为零<br>JG	     有符号大于（ZF&#x3D;0且SF&#x3D;OF）<br>JNLE	 有符号大于（ZF&#x3D;0且SF&#x3D;OF）<br>JGE	     有符号大于等于（SF&#x3D;OF）<br>JNL	     有符号大于等于（SF&#x3D;OF）<br>JL	         有符号小于（SF≠OF）<br>JNGE	 有符号小于（SF≠OF）<br>JLE	     有符号小于等于（ZF&#x3D;1或SF≠OF）<br>JNG	     有符号小于等于（ZF&#x3D;1或SF≠OF）<br>JO	     溢出（OF&#x3D;1）<br>JNO	    未溢出（OF&#x3D;0）<br>JS	       负数 （SF&#x3D;1）<br>JNS	   非负数（SF&#x3D;0）</p>
<h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><p>分类                        	示例指令	                             功能<br>数据传输指令	           MOV	                         从一个位置复制数据到另一个位置<br>                 PUSH	                       将数据推入堆栈<br>                 POP	                           将数据从堆栈弹出<br>                 XCHG	                       交换两个位置的数据<br>                 LEA	                           加载地址<br>                 MOVS	                       将一个字符串的数据复制到另一个字符串<br>                 LODS	                        将数据从一个位置加载到累加器<br>                 STOS	                        将累加器中的数据存储到一个位置<br>算术和逻辑指令     	  ADD                         	将两个数相加<br>                 SUB	                           从一个数中减去另一个数<br>                 MUL	                       执行无符号乘法<br>                 DIV	                           执行无符号除法<br>                AND	                        执行逻辑与操作<br>                OR	                            执行逻辑或操作<br>                XOR	                            执行异或操作<br>                NOT	                            执行逻辑非操作<br>控制流指令	            JMP	                            无条件跳转到指定地址<br>                Jcc	                           条件跳转指令，根据标志位执行跳转<br>                CALL	                       调用子程序或函数<br>                RET	                            返回子程序或函数调用点<br>                INT	                           触发中断服务例程<br>                LOOP	                       根据计数器值循环执行指令<br>                HLT	                           暂停处理器运行<br>状态标志位指令	    CMP	                        比较两个数<br>                TEST	                       按位进行与操作并更新标志位<br>                CLC	                           清除进位标志位<br>                STC	                           设置进位标志位<br>                CMC	                       取反进位标志位<br>                CLD	                           清除方向标志位<br>                STD	                           设置方向标志位<br>字符串和循环指令	MOVS	                       将一个字符串的数据复制到另一个字符串<br>                CMPS	                       比较两个字符串的数据<br>                SCAS	                      在字符串中搜索指定的数据<br>                REP	                           重复执行指令块<br>                REPE&#x2F;REPZ	               如果相等则重复执行指令块<br>                REPNE&#x2F;REPNZ         	如果不相等则重复执行指令块<br>堆栈指令	                PUSH	                        将数据推入堆栈<br>                POP	                           将数据从堆栈弹出<br>                PUSHAD	                   将所有通用寄存器的值推入堆栈<br>                POPAD	                   将所有通用寄存器的值从堆栈弹出<br>                PUSHA	                       将通用寄存器的值推入堆栈<br>                POPA	                       将通用寄存器的值从堆栈弹出<br>过程和函数指令	     CALL	                        调用子程序或函数<br>                RET	                           返回子程序或函数调用点<br>                ENTER                     	建立堆栈帧<br>                LEAVE                      	恢复调用者的堆栈帧<br>                PROC	                       定义一个过程<br>                ENDP	                       定义过程结束<br>I&#x2F;O指令	                 IN	                            从指定端口读取数据<br>                OUT	                          将数据写入指定端口<br>                INS	                           从数据端口读取数据到字符串<br>                OUTS	                      将字符串的数据写入到数据端口<br>                CLI	                          关中断<br>                STI	                          开中断</p>
<h3 id="REP前缀的概念"><a href="#REP前缀的概念" class="headerlink" title="REP前缀的概念"></a>REP前缀的概念</h3><ul>
<li>“rep”指令前缀表示重复执行某项操作。例如，“stos”是一条可单独执行的指令，表示存储字节到目标地址。“rep stos”表示重复执行“stos”指令，直到“ecx”为0。</li>
<li>类似的指令还有“rep lods”、“rep movs”等。</li>
</ul>
<h4 id="REP-STOS的实际操作"><a href="#REP-STOS的实际操作" class="headerlink" title="REP STOS的实际操作"></a>REP STOS的实际操作</h4><ul>
<li>使用ecx作为计数器：“rep”指令前缀使用“ecx”作为计数器，表示重复执行“stos”指令的次数。每次执行时，“ecx”都会递减，当“ecx”为0时，结束重复执行。每次存储一个字节或一个双字。</li>
<li>存储值到目标地址：“rep stos”表示存储“al”或“eax”的值到“edi”指向的目标地址。</li>
<li>edi值的自增：每次存储一个字节或一个双字后，“edi”的值自增，指令的执行结果为存储到连续的内存空间。</li>
<li> 启动设置<br> 设置“edi”为存储的起始目标地址。<br> 设置“eax”或“al”为被存储的值。<br> 设置“ecx”为执行次数。</li>
</ul>
<h4 id="REP-MOVS操作原理"><a href="#REP-MOVS操作原理" class="headerlink" title="REP MOVS操作原理"></a>REP MOVS操作原理</h4><ul>
<li>与REP STOS类似：“REP MOVS”与“REP STOS”指令类似，重复执行“movs”指令多次，直到“ecx”的值为0。</li>
<li>实际操作：<br>1. 每次移动一个字节或一个双字，从[esi]地址的字符移动到[edi]内存中。<br>2. 每次执行“movs”操作后，“esi”和“edi”的值都会被增加。<br>3. 启动设置</li>
<li>设置“edi”为存储的起始目标地址。</li>
<li>设置“esi”为存储的起始源地址。</li>
<li>设置“ecx”为执行次数。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/x86/" data-id="cm8vg7hk40000d8v613s87k6u" data-title="x86" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T09:19:51.640Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/30/hello-world/" data-id="cm8vfjkke0000zsv6gy3q8iom" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/30/PTF/">PTF</a>
          </li>
        
          <li>
            <a href="/2025/03/30/MISC-%E9%9A%90%E5%86%99/">MISC-隐写</a>
          </li>
        
          <li>
            <a href="/2025/03/30/HTML/">HTML</a>
          </li>
        
          <li>
            <a href="/2025/03/30/base64%E8%A7%A3%E7%A0%81%E8%84%9A%E6%9C%AC/">base64解码脚本</a>
          </li>
        
          <li>
            <a href="/2025/03/30/python/">python</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>